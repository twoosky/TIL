# 트랜잭션
* 트랜잭션은 데이터베이스의 `상태를 변화`시키기 위해 수행하는 `작업 단위`이다. 즉, 한 번에 수행되어야 할 일련의 연산을 말한다.
* `상태를 변화` 시킨다는 것은 SQL 쿼리를 통해 DB에 접근하는 것이다. (SELECT, INSERT, DELETE, UPDATE)
* `작업의 단위`는 질의어 한 문장이 아니다. 작업을 하기 위해 실행되는 쿼리의 묶음이다. 이때 단위의 기준은 개발자가 정하게 된다.  

### 예시
* 만약 쇼핑몰을 운영한다고 해보자. 가장 중요한 것은 구매, 판매일 것이다.
* 고객이 상품을 구매하는 과정을 *하나의 단위* 로 정하게 된다면, 아래 3개의 쿼리문이 `하나의 트랜잭션` 이 되는 것이다.  
```sql  
-- 유저 정보 가져오기  
SELECT 아이디, 번호, 주소  
FROM CUSTOMER   
WHERE 아이디 = 'plitche';  
   
-- 주문하기  
INSERT INTO ORDER  
VALUES ('주문번호', 'plitche', '번호', '주소', '상품정보');  
   
-- 상품 재고 수정하기  
UPDATE ITEM   
SET 재고 = 재고-1  
WHERE 상품이름 = '코트'  
```

### 트랜잭션이 필요한 이유
위 예제에서 어떤 오류로 인해 주문은 되었는데 상품 재고 수정은 안되었다고 생각해보자. 주문은 계속해서 되고 있는데 상품 재고가 없어서 발송이 어려운 상황이 생길 수 있다.
이러한 오류를 방지하기 위해 트랜잭션이 필요하다. 트랜잭션으로 원하는 `작업의 단위`를 정하게 되면 작업을 수행하는 도중 문제가 발생한 경우 이전에 진행되었던 작업도 
진행되지 않는다. 모든 작업을 안정적으로 끝마친 후에야 실제 데이터베이스에 반영이 되는 것이다.   
즉, 주문은 되었는데 상품 재고 수정이 안된 경우 트랜잭션을 모두 수행하기 전 오류가 발생했으므로 주문도 진행되지 않는다.

## 트랜잭션의 성질
* `Atomicity: 원자성`  
  * 하나의 트랜잭션은 더 작게 나눌 수 없는 최소 단위이다.
  * 트랜잭션이 모두 반영되거나, 아니면 전혀 반영되지 않아야 하는 특징이다.
* `Consistency: 일관성`
  * 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관성 있는 상태를 유지해야 한다.
  * 즉, 트랜잭션 수행 후에도 데이터베이스의 모든 제약조건을 만족해야 한다.
  * 예를 들면, 고객 정보가 담겨있는 데이터베이스에 새로운 고객이 등록되면 그 데이터베이스를 참조하는 다른 하위 계층의 데이터베이스도 같은 고객의 세부 정보를 가져와야 한다.  
  * 또는 모든 계좌의 돈은 0원 이상이어야 한다. 라는 무결성 제약이 있다면 이를 위반하는 트랜잭션은 모두 중단되어야 한다.
* `Isolation: 독립성`
  * 둘 이상의 트랜잭션이 실행되고 있을 경우, 어떤 특정 트랜잭션이라도 다른 트랜잭션에 끼어들 수 없다. 
  * 독립성이 보장된다면 계좌 이체작업을 진행하고 있는 도중에 계좌의 잔액을 조회한다거나 인출하는 등의 작업을 동시에 수행할 수 없게 되는 것이다.
* `Durability: 지속성`
  * 트랜잭션을 성공한 후 결과는 데이터베이스에 영구적으로 반영되어야 한다.

## 롤백과 커밋
트랜잭션을 사용해 데이터를 추가하다 에러가 발생하게 되면 어떻게 처리하게 될까? 이때 트랜잭션을 롤백하여 종료할 수 있다.   
롤백을 진행하면 트랜잭션 내에서 행해진 모든 변경사항이 없었던 일이 된다. 트랜잭션 도중에 아무런 에러가 발생하지 않는다면 커밋을 하게 된다.   
그러면 트랜잭션의 모든 변경사항이 데이터베이스에 반영된다.

* `Rollback: 롤백`
  * 하나의 트랜잭션 처리가 비정상적으로 종료(트랜잭션의 성질이 깨진 경우)되면 트랜잭션의 원자성을 위해 해당 트랜잭션에서 작업한 모든 연산을 취소하여 실제 데이터베이스에 반영하지 않는다. 
  * 롤백하고 난 후에는 해당 트랜잭션을 재시작하거나 폐기하여야 한다.
* `Commit: 커밋`
  * 하나의 트랜잭션 작업이 정상적으로 완료되었을 때 커밋을 하게 된다.
  * 커밋을 하면 트랜잭션 실행 결과가 데이터베이스에 반영된다.

## 트랜잭션 상태
* `Active(활동 상태)`: 트랜잭션이 수행을 시작하여 현재 수행 중인 상태
* `Partially Committed(부분 완료 상태)`: 마지막 연산이 실행된 직후의 상태, 연산은 모두 처리했지만 데이터 베이스에 반영되지 않은 상태
* `Commited(완료 상태)`: 트랜잭션이 성공적으로 완료되어 Commit을 한 상태
* `Failed(실패 상태)`: 장애가 발생하여 트랜잭션이 중단된 상태
* `Aborted(철회 상태)`: 수행에 실패하여 Rollback 연산을 실행한 상태

## 주의사항
트랜잭션의 범위가 커질수록 데이터베이스 커넥션을 소유하고 있는 시간이 늘어난다. 일반적으로 데이터베이스 커넥션 수는 제한적이므로, 커넥션 소유 시간이 길어질수록 사용 가능한 커넥션 개수가 줄어든다. 어느 순간에는 각 단위의 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다. 따라서, 트랜잭션 범위를 최소화하는 것이 중요하다.

### 예시
게시판에 게시물을 작성한 후 저장 버튼을 클릭했을 때 서버에서 처리하는 내용을 순서대로 정리한 것이다. (RealMysql 8.0 에시)
```sql
-- BAD
1) 처리시작
=> 데이터베이스 커넥션 생성 => 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
<= 트랜잭션 종료(COMMIT)
< = 데이터베이스 커넥션 반납
10) 처리 완료
```
* 실제로 DBMS에 데이터를 저장하는 작업은 5번부터 시작된다. 위처럼 1번과 2번 사이에서 트랜잭션을 시작하면 트랜잭션의 범위가 커 커넥션을 소유하고 있는 시간이 늘어날 것이다. 따라서, 4번과 5번 사이에 트랜잭션을 시작하는 것이 효율적이다.
* 8번은 외부의 원격 서버와 통신하는 작업이다. 원격 서버가 장애가 발생해 통신할 수 없게된다면, 커넥션을 소유하고 있는 시간이 늘어날 것이다.
* DBMS 작업이 크게 4가지 있다. 5,6번은 하나의 트랜잭션으로 묶어야 하며, 7번은 단순 조회인 경우 트랜잭션에 포함할 필요가 없다. 9번은 4,5번 작업과 다른 성격의 작업이므로 트랜잭션을 분리해도 무방하다.
```sql
-- GOOD
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 발생 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
=> 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
=> 트랜잭션 시작
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
<= 트랜잭션 종료(COMMIT)
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
=> 트랜잭션 시작
9) 알림 메일 발송 이력을 DBMS에 저장
<= 트랜잭션 종료(COMMIT)
<= 데이터베이스 커넥션 종료(또는 커넥션 풀에 반납)
10) 처리 완료
```

### 결론
프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다.  
네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다. (메일전송, 파일전송 등)
