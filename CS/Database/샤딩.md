# 샤딩
* 큰 데이터를 여러 서브셋으로 나누어 **여러 인스턴스**에 저장하는 방법이다. 이때 각 서브셋을 샤드(shard)라고 한다.
  * 파티셔닝은 하나의 인스턴스에서 테이블을 분리하여 사용한다.
* 데이터를 여러 인스턴스로 분산해 쿼리할 데이터의 양이 줄어듦에 따라 쿼리 성능을 향상시킬 수 있다.

**단점**
1. `재샤딩에 비용이 많이 든다` : 추후, 수요가 증가/감소해 서버를 추가/제거하는 경우 데이터를 재샤딩하는 것이 복잡하다. 데이터를 샤딩하기 위해 주어진 조건에 따라 데이터를 다시 정렬해야 하므로, 비용이 많이 든다.
2. `샤드는 불균형이 될 수 있다` : 샤드를 나누는 방식에 따라 데이터 불균형이 발생할 수 있다.
3. `샤드 병합이 복잡하다`
4. `Join 비용이 증가한다` : 데이터가 여러 서버에 분산되어 있는 경우 모든 서버에서 조인 작업을 수행해야 하므로 매우 복잡하다.
<br></br>
## 샤딩 종류
### 1. Hash Sharding
* 열, 또는 열 조합을 선택하고 해시 함수 결과값을 통해 샤드를 결정하는 방식이다.
* 아래 그림은 그 중 하나인 Modular Sharding 방식으로 PK값의 모듈러 연산 결과를 통해 샤드를 결정하는 방식이다.
* PK값을 샤드의 개수로 모듈러 연산해 해시값을 얻으므로, 총 샤드 수가 정해져있을 때 유용하다.
* `단점` : 샤드 추가/감소 시 해시 함수 변경이 필요하고, 이에 따라 데이터를 재정렬 해야한다. (재샤딩)
  
<img width="424" alt="image" src="https://github.com/twoosky/TIL/assets/50009240/87289448-38f8-4b1d-a72e-1f46e5291595">

### 2. Range Based Sharding
*  범위(날짜 범위, 기본 키 등)를 기반으로 샤드를 만드는 방식이다.
*  아래와 같이 PK가 0-9인 데이터는 0번 샤드에, 10-19인 데이터는 1번 샤드에 저장할 수 있다.
*  샤드 추가/감소 비용이 Hash Sharing 방식보다는 낮다.
*  `단점`: 샤드의 불균형이 발생할 수 있다. 즉, 특정 샤드에만 부하가 집중될 수 있다.

<img width="450" alt="image" src="https://github.com/twoosky/TIL/assets/50009240/ad0cc4ef-b000-401f-be64-cd34efb9dad5">

### 3. Entity Group Based Sharding

이 접근 방식에서는 항목 그룹을 기반으로 데이터를 분할합니다. 사용자 데이터를 기반으로 데이터를 분할하지만 해당 사용자와 관련된 데이터가 있을 수 있다고 가정해 보겠습니다. 관계형 데이터를 다른 샤드에 보관하면 조인 작업을 수행하는 것이 복잡해집니다. 
이를 극복하기 위해 우리는 해당 사용자와 관련된 모든 데이터를 동일한 샤드에 보관합니다. 조인 작업을 간단하게 수행하면 쿼리 성능도 최적화됩니다.
