# Sync vs Async, Blocking vs Non-Blocking
보통 동기 = 블로킹을 같은 개념으로, 비동기 = 논블로킹을 같은 개념으로 헷갈리는 경우가 많다. 
하지만 두 개념은 각각을 구분짓는 기준이 전혀 다르다. 
`Blocking/Non-Blocking`은 제어의 관점에서 바라보는 것 즉, 한 작업이 처리되는 동안 다른 작업도 처리될 수 있는지에 대한 이야기이고,   
`동기/비동기`는 순서와 결과(처리)의 관점에서 바라보는 것 즉, 작업들이 시간을 맞춰서 실행되는지 아닌지에 대한 이야기이다.

* `제어권`: 함수 내용을 실행시킬 수 있는 권리이다.
* `결과값`: 함수의 리턴값이다.

```c++
function 부모함수() {
  A();
  B();
  ...
}
```

```c++
function A() {
  let a = 1;
  let b = 2;
  let sum = a + b;
  return sum;
}
```

## Blocking
`Blocking`이란 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것이다.
> 다른 함수를 호출할 때, 제어권도 함께 넘겨주고, 호출한 함수의 작업이 끝난 후에 돌려받는 방식이다.  
> 위의 예시에선 부모함수가 A를 실행시킬 때 제어권을 아예 넘겨주므로 B를 실행하지 못하고 A의 작업이 끝날 때까지 기다린다.  
> 요청한 작업을 마칠 때까지 계속 기다린다.  

## Non-Blocking
`Non-Blocking`이란 다른 주체의 작업에 관련없이 자신의 작업을 하는 것이다.  
> 다른 함수를 호출할 때 제어권을 넘겨주기는 하지만, 바로 돌려받는다.  
> 부모함수가 A를 실행시킬 때 A의 작업이 안끝나도 바로 제어권을 돌려받고 부모함수는 B를 실행시킨다.  
> 즉, 부모함수는 계속 제어권을 가지고 있기 때문에 A함수를 호출한 이후에도 자신의 코드를 계속 실행한다.  
> 요청한 작업을 즉시 마칠 수 없다면 즉시 리턴해 제어권을 돌려받는다.  

## Synchronous: 동기
작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작함을 의미한다.  
요청에 대한 응답이 오면 다음 작업을 요청하는 것이다.
> 함수를 호출한 곳에서 호출된 함수가 결과를 반환할 때까지 작업 완료 여부를 계속 확인하며 대기하는 방식이다.   
> 구성은 단순하나, 멀티태스킹이 불가하다.  

## Asynchronous: 비동기
시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음을 의미한다.  
요청에 대한 응답을 기다리지 않고 다음 작업을 요청하는 것이다.
> 함수를 호출하는 곳에서 결과를 기다리지 않고 `callback 함수`가 결과를 처리한다. 즉, 작업 완료 여부를 확인하지 않는다.    
> 멀티태스킹이 가능하다 복잡도가 증가한다.(부하 컨트롤, 데이터 일관성 유지 등)

> callback 함수란?  
> OS가 실행하는 함수로 특정 이벤트가 발생하면 실행되는 함수이다.

# Blocking/Non-Blocking, Sync/Async 조합
<img src="https://user-images.githubusercontent.com/50009240/181597770-be41d6cd-3469-4aaf-88c6-16202748a9f6.jpg" width="800" height="350">

## Blocking/Sync
Blocking의 관점은 제어권에 있고, Sync의 관점은 결과의 처리에 있다.  
따라서 제어권이 없으므로 결과를 반환할 때까지 기다리다 결과값이 반환되면 즉시 해당 업무를 처리하게 된다. 
> 자바에서 입력요청을 할 때 `Blocking/Sync`가 사용된다.
> ```java
> public static void main(String[] args) {
>   System.out.print("출력하고 싶은 메시지를 입력해주세요: ");
>   final Scanner scanner = new Scanner(System.in);
>   String message = scanner.nextLine();
>   System.out.println("블로킹 동기");
>   System.out.println(message);
> }
> ```
> 
> 입력요청 시 제어권이 넘어갔기 때문에 아래 내용이 실행되지 않는다.(Blocking)  
> 입력을 하면 제어권과 결과(입력값)을 같이 받아 출력한다.(동기)

## Non-Blocking/Sync
Non-Blocking은 다른 작업이 있어도 자신의 제어권을 가지고 작업을 하는 것이고, Sync(동기)의 관점은 결과에 있다.  
따라서 중간중간마다 다른 작업이 완료되었는지 물어본다. 
> 1. 다른 작업 완료 여부를 물어본다. 
> 2. 결과가 안나온 경우 돌아가 자신의 작업을 수행한다.   
> 3. 또 다시 다른 작업이 완료되었는지 물어본다.
> 4. 1 ~ 3 과정 반복
> 5. 다른 작업이 완료되었으면 해당 결과를 가져와 즉시 업무를 처리한다.

<img src="https://user-images.githubusercontent.com/50009240/181602785-0b378a24-1b5e-4bb0-9974-bf20629c0e67.jpg" width="850" height="380">

## Blocking/Async
Blocking은 자신의 작업에 대한 제어권이 없고, 비동기(Async)는 결과를 바로 처리하지 않아도 된다.  
> 비동기라 결과를 즉시 처리하지 않아도 되는데, 왜 작업이 끝날 때까지 대기해야될끼?    
> => 굳이 비동기인데 Blocking을 써야 할까?  
> 보통 Non-Blocking/Async로 하려다가 개발자의 실수로 혹은 기타 이유로 위와 같이 동작하는 경우가 있다고 한다.  

## Non-Blocking/Async
Non-Blocking은 다른 작업이 시작되어도 제어권을 갖고 자신이 하던 작업은 멈추지 않는다.   
따라서 양쪽에서 서로 각자 작업을 처리하게 된다.  
Async는 결과를 바로 처리하지 않는 것이다.  
따라서 다른 작업에서 끝난 결과를 바로 처리하지 않고, 자신의 일이 끝나게 되면 그때서야 처리하게 된다.  
> 즉, `Non-Blocking/Async`는 양쪽에서 서로 각자 작업을 수행하다가 다른 작업이 끝나도 결과를 바로 처리하지 않고,   
> 자신의 작업이 끝나면 그때 다른 작업의 결과를 처리한다.  
> 
> 대표적인 예시로, 자바스크립트에서 API 요청을 하고 다른 작업을 하다가 콜백을 통해서 추가적인 작업을 처리할 때   
> `Non-Blocking/Async`을 사용한다.



||Blocking|Non-Blocking|
|---|---|---|
|Sync|Blocking/Sync|Non-Blocking/Sync|
|Async|Blocking/Async|Non-Blocking/ASync|
