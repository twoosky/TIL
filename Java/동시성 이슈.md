# 동시성 이슈
**CPU-RAM 아키텍처와 동시성 프로그래밍에서 발생할 수 있는 문제점**

![download (17)](https://github.com/twoosky/TIL/assets/50009240/dd00efbc-71ed-44aa-bf7a-79ee71523a8c)

데이터 처리 과정
1. CPU가 어떤 작업을 처리하기 위해 필요한 데이터를 RAM에서 읽어 CPU Cache Memory에 복제한다.
2. 작업을 처리한 뒤, 변경된 CPU Cache Memory 데이터를 RAM으로 쓰기 작업 한다.

문제점
* CPU Cache Memory가 변경되었다고, 바로 RAM에 쓰기 작업을 수행하지 않는다.
* 반대로, RAM의 데이터가 변경되었다고, 바로 CPU Cache Memory으로 가져오지 않는다.
* 따라서, 동시성 프로그래밍에서는 CPU와 RAM 중간에 위치하는 CPU Cache Memory의 병렬성 특징때문에, 다수의 스레드가 공유 자원에 접근할 때 `가시성(visibility)`, `동시성(concurrency)` 문제가 발생할 수 있다.

## 가시성: visibility
`가시성`: CPU Cache Memory와 RAM의 데이터가 서로 일치하지 않아 발생하는 문제
```java
public class Main {
    private static boolean stopRequested;

    public static void main(String[] args) throws InterruptedException {
        Thread background = new Thread(() -> {
            for (int i = 0; !stopRequested; i++);
            System.out.println("background 스레드 종료");
        });

        background.start();

        TimeUnit.SECONDS.sleep(1);
        stopRequested = true;
        System.out.println("main 스레드 종료");
    }
}
```
* 메인 스레드가 1초 후 stopRequested를 true로 설정하면, background 스레드는 반복문을 빠져나와 종료되고, 메인 스레드도 종료될 것이라 예상
* `실행 결과`: 메인 스레드만 종료
```java
main 스레드 종료

// backgroundThread 종료되지 않고, 계속 살아 있음
```

**동작 과정**
1. CPU1에서 background 스레드가 동작하고, CPU2에서 main 스레드가 동작한다고 가정
2. 각 CPU는 RAM에 있는 `stopRequested=false` 공유 자원을 CPU Cache Memory로 복제
3. 1초 이후, main 스레드에서 stopRequested를 true로 변경
4. 하지만, background 스레드에서는 CPU Cache Memory에 있는 stopRequested를 참조하므로 무한 루프 수행 (가시성 문제)

**가시성 문제 해결: valatile**
* 공유 자원에 `volatile` 키워드를 붙여 가시성 문제를 해결할 수 있다.
* `volatile`을 붙인 공유 자원은 CPU Cache Memory을 거치지 않고 RAM에서 직접 읽고 쓰는 작업을 수행한다.
```java
private static volatile boolean stopRequested;
```

## 동시 접근 문제: concurrency
* 동시 접근 문제 즉, 원자성 문제
```java
public class Main {
    private static int count;

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            for(int i = 0; i < 100000; i++) {
                ++count;
            }
        });

        Thread thread2 = new Thread(() -> {
            for(int i = 0; i < 100000; i++) {
                ++count;
            }
        });

        thread.start();
        thread2.start();

        TimeUnit.SECONDS.sleep(5);
        System.out.println(count);
    }
}
```

> https://badcandy.github.io/2019/01/14/concurrency-02/  
> https://steady-coding.tistory.com/554  
> https://backtony.github.io/java/2022-05-27-java-51/  
> https://backtony.github.io/java/2022-05-04-java-50/
