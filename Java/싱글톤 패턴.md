# 싱글톤 패턴 : Singleton pattern
* 객체의 인스턴스를 오직 1개만 생성해 사용하는 패턴이다.

```java
pubic class Singleton {
  private static Singleton instance = new Singleton();
  
  private Singleton() {
     // 생성자는 외부에서 호출 못하게 private으로 지정해야 한다.
  }
  
  public static Singleton getInstance() {
    return instance;
  }
  
  public void say() {
    System.out.println("hi, there");
  }
}
```
* static 영역에 객체 instance를 미리 하나 생성해서 메모리에 올려둔다.
* java에서는 `생성자를 private`으로 선언해 다른 곳에서 해당 객체를 생성하지 못하도록 만들고, `getInstance()` 메소드를 통해 인스턴스를 받아 사용하도록 구현한다.

### 싱글톤 패턴 사용이유  
* 최초 한번의 new 연산자(객체 생성)를 통해 얻은 고정된 메모리 영역을 재사용하기 때문에 메모리 낭비를 방지한다.
* 싱글톤 인스턴스는 `전역성`을 띄므로 데이터 공유에 용이하다. 즉, 다른 클래스의 인스턴스들이 데이터를 공유하고 변경할 수 있다.

### 싱글톤 패턴 문제점
1. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
    * static 필드로 해당 인스턴스를 미리 생성해두고,
    * 만들어둔 인스턴스의 참조를 반환하는 메서드 정의 : getInstance()
    * private 생성자
    * 기본적으로 위의 3가지가 들어간다.
2. 의존관계상 클라이언트가 구체 클래스에 의존하므로 SOLID 원칙 중 `DIP`와 `OCP` 원칙을 위반할 가능성이 높다.
    * `DIP` 위반: 구체 클래스를 참조해서 getInstance() 호출로 해당 인스턴스 참조를 가져와야 하므로 인터페이스 참조로는 구현이 불가능하다.
    * `OCP` 위반: 구체 클래스가 바뀌면 클라이언트 코드도 바뀌어야 한다.
3. 싱글톤 인스턴스는 자원을 공유하므로 다른 클래스들 간의 결합도가 높아져 테스트하기 어렵다.
4. 내부 속성을 변경하거나 초기화하기 어렵다.
5. private 생성자이므로, 자식 클래스를 만들기 어렵다.
    * 자식 클래스를 생성하려면 부모 객체의 기본 생성자가 public으로 접근 가능해야한다.

> 결론적으로, 싱글톤 패턴은 유연성이 많이 떨어진다.  
> 하지만 스프링 컨테이너와 같은 프레임워크와 함께 사용한다면 문제점 보완 및 장점을 누릴 수 있다.  
> 실제로 스프링 컨테이너는 객체 인스턴스(Bean)를 싱글톤으로 관리한다.
