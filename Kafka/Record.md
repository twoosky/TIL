# Record
* `레코드`는 타임스탬프, 헤더, 메시지 키, 메시지 값, 오프셋으로 구성되어 있다.
* 프로듀서가 생성한 레코드가 브로커로 전송되면 오프셋과 타임스탬프가 지정되어 저장된다.
* 브로커에 한번 적재된 레코드는 수정할 수 없고, 로그 리텐션 기간 또는 용량에 따라서만 삭제된다. [(참고)](https://github.com/twoosky/TIL/blob/main/Kafka/Broker.md)
<img src="https://github.com/twoosky/TIL/assets/50009240/25e59964-3efc-42c5-b3d3-5eae3f32c62a" width="280" height="220">
<br></br>

**1. 타임스탬프**
* 레코드의 타임스탬프는 스트림 프로세싱에 활용하기 위한 시간을 저장하는 용도로 사용된다.
* 카프카 0.10.0.0 이후 버전부터 추가된 타임스탬프는 Unix timestamp가 포함되며, 프로듀서에서 따로 설정하지 않으면 기본값으로 ProducerRecord 생성 시간(CreateTime)이 들어간다.
* 또는 브로커 적재 시간 (LogAppendTime)으로 설정할 수도 있다.
* 해당 옵션은 토픽 탄위로 설정 가능하며 `message.timestamp.type`을 사용한다.

**2. 오프셋**
* 레코드의 오프셋은 프로듀서가 전송한 레코드가 Broker에 적재될 때 지정된다.
* 즉, 프로듀서가 생성한 레코드에는 존재하지 않는다.
* 컨슈머는 오프셋을 기반으로 처리가 완료된 데이터와 앞으로 처리해야할 데이터를 구분한다.
* 각 메시지는 파티션별로 고유한 오프셋을 가지므로, 컨슈머에서 중복 처리를 방지하기 위한 목적으로도 사용된다.

**3. 헤더**
* 레코드의 헤더는 0.11부터 제공된 기능이다.
* key/value 데이터를 추가할 수 있다.
* 레코드의 스키마 버전이나 포맷과 같이 데이터 프로세싱에 참고할만한 정보를 담아서 사용할 수 있다.

**4. 메시지 키: key**
* 메시지 키는 메시지의 값을 분류하기 위한 용도로 사용되며, 이를 `파티셔닝`이라고 한다.
* 메시지 키는 파티셔너(Partitioner)에 따라 토픽의 파티션 번호가 정해진다.
* 메시지 키는 필수 값이 아니며, 지정하지 않으면 null로 설정된다.
* 메시지 키가 null인 레코드는 라운드 로빈에 의해 특정 토픽의 파티션에 전달된다.
* null이 아닌 메시지 키는 해쉬값에 의해서 특정 파티션에 매핑되어 전달된다.

**5. 메시지 값: value**
* 실질적으로 처리할 데이터가 담기는 공간
* 메시지 값의 포맷은 제네릭으로 사용자에 의해 지정된다.
* 필요에 따라 사용자 지정 포맷으로 직렬화/역직렬화 클래스를 만들어 사용할 수도 있다.
* 브로커에 저장된 레코드의 메시지값은 어떤 포맷으로 직렬화되어있는지 알 수 없기 때문에 ***컨슈머는 미리 역직렬화 포맷을 알고 있어야 한다.***
