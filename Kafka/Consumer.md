# Consumer
* 프로듀서가 전송한 데이터는 카프카 브로커에 적재되고, 컨슈머는 브로커로부터 데이터를 가져와 필요한 처리를 한다.
* 컨슈머는 리더 파티션을 갖는 카프카 브로커와 직접 통신한다.
  
## Consumer 내부 구조
* `Fetcher`: 리더 파티션으로부터 레코드들을 미리 가져와서 대기 (브로커로부터 배치 단위로 가져옴)
* `poll()`: Fetcher에 있는 레코드들을 리턴하는 레코드
* `ConsumerRecords`: 처리하고자 하는 레코드들의 모음. 오프셋이 포함되어 있다.

<img width="530" alt="image" src="https://github.com/twoosky/TIL/assets/50009240/3dfa4cd2-4e37-474b-ab7a-f459cdf19855">

## Consumer Group
* 컨슈머 그룹은 특정 토픽에 대해서 목적에 따라 데이터를 처리하는 컨슈머들을 묶은 그룹 (간단하게는 하나의 서비스)
* 컨슈머 그룹에서 토픽에 대한 레코드를 가져가도 레코드는 삭제되지 않는다.
* 따라서, 하나의 토픽에 대해 여러 컨슈머 그룹이 레코드를 consume할 수 있게 된다.
* 1개의 파티션은 컨슈머 그룹 내 1개의 컨슈머에만 할당 가능하다.
* 컨슈머는 여러 개의 파티션에 할당될 수 있다. (파티션:컨슈머 = n:1)
* 컨슈머 그룹의 컨슈머 개수는 해당 토픽의 파티션 개수보다 같거나 작아야 한다. (같으면 최대 성능)
  * 파티션 개수보타 컨슈머 그룹의 컨슈머 개수가 많은 경우 1개의 컨슈머는 파티션을 할당받지 못하고, 유휴 상태로 남게 된다. (아무 작업도 못하고 스레드만 차지함) 

<img width="770" alt="image" src="https://github.com/twoosky/TIL/assets/50009240/1b180ed6-a711-4d51-819f-3ef94d936647">

> `Consumer Group 사용 이유`: 애플리케이션 서버가 죽는 경우 서버가 복구된 뒤 컨슈머 그룹의 커밋 오프셋을 기준으로 레코드를 가져오면 되므로 데이터 손실 최소화, 각각의 서비스를 컨슈머 그룹으로 나눔으로써 서비스간 결합도 최소화

## 리밸런싱 (Rebalancing)
* 리밸런싱은 컨슈머에 장애가 발생한 경우 해당 컨슈머에 할당된 파티션의 소유권을 다른 컨슈머로 이관하는 작업이다.
* 리밸런싱이 발생하는 상황
  * 컨슈머가 추가되는 상황: 데이터 처리량 분산을 위해 파티션을 컨슈머에 재할당
  * 컨슈머가 제외되는 상황: 이슈가 발생한 컨슈머를 컨슈머 그룹에서 제외하고, 해당 컨슈머의 파티션을 다른 컨슈머에 재할당
* 파티션 개수가 많아지면 리밸런싱 시간이 오래걸리므로 리밸런싱에 대응하는 로직을 구현해야 한다. [리밸런싱 처리 참고](https://techblog.gccompany.co.kr/%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%BB%A8%EC%8A%88%EB%A8%B8-%EA%B7%B8%EB%A3%B9-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-kafka-consumer-group-rebalancing-5d3e3b916c9e)
<img width="530" alt="image" src="https://github.com/twoosky/TIL/assets/50009240/33ebb220-865b-496d-9bef-d3eb2a5b6069">

## 커밋 (Commit)
* 컨슈머는 카프카 브로커로부터 레코드를 어디까지 가져갔는지 커밋을 통해 기록한다.
* 특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째까지 가져갔는지 카프카 브로커 내부 __consumer_offsets 토픽에 기록된다.
* 오프셋 커밋이 제대로 되지 않는다면, 데이터 처리의 중복이 발생할 수 있다. 이를 방지하기 위해 컨슈머 애플리케이션이 오프셋 커밋을 정상적으로 처리했는지 검증해야 한다.

<img width="530" alt="image" src="https://github.com/twoosky/TIL/assets/50009240/8b823639-3337-4f4d-8703-4f647c011ebc">

