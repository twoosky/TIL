# 템플릿 메서드 패턴과 콜백 패턴
**템플릿 메서드 패턴**
* 상위 클래스의 템플릿 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴
* 템플릿 메서드 패턴은 상속을 통해 동일한 부분(핵심 기능)은 상위 클래스로, 달라지는 부분(부가 기능)만 하위 클래스로 분할하여 사용하는 패턴
* 템플릿 메서드 패턴은 상속을 사용해서 따라서 상속에서 오는 단점들을 그대로 가지고 있음(부모-자식 의존)

**템플릿 메서드 패턴 예제 코드**
```java
@Slf4j
public abstract class AbstractTemplate {
   
   // 변하지 않는 부분
   public void execute() {
      long startTime = System.currentTimeMillis();
      call(); //상속
      long endTime = System.currentTimeMillis(); 
      long resultTime = endTime - startTime; 
      log.info("resultTime={}", resultTime);
   }

   // 변하는 부분
   protected abstract void call();
}
```
```java
@Slf4j
public class SubClassLogic1 extends AbstractTemplate {
   @Override
   protected void call() {
      log.info("비즈니스 로직1 실행"); 
   }
}
```
```java
@Slf4j
public class SubClassLogic2 extends AbstractTemplate {
   @Override
   protected void call() { 
      log.info("비즈니스 로직2 실행");
   } 
}
```
```java
public class TemplateMethodTest {
   @Test
   void templateMethodV1() {
      AbstractTemplate template1 = new SubClassLogic1(); 
      template1.execute();
      AbstractTemplate template2 = new SubClassLogic2();
      template2.execute(); 
   }
}
```
**전략 패턴**
* 클라이언트가 전략을 생성해 전략을 실행한 컨텍스트에 주입하는 패턴
* 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴
* 변하지 않는 부분을 Context 라는 곳에 두고, 변하는 부분을 Strategy 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결
* Context 는 내부에 Strategy strategy 필드를 가지고 있어서 이 필드에 변하는 부분인 Strategy 의 구현체를 주입
* 전략 패턴의 핵심은 Context 는 Strategy 인터페이스에만 의존

**전략 패턴 예제 코드**
```java
public interface Strategy {
   void call();
}
```
```java
@Slf4j
public class StrategyLogic1 implements Strategy {
   
   @Override
   public void call() {
      log.info("비즈니스 로직1 실행"); 
   }
}
```
```java
@Slf4j
public class StrategyLogic2 implements Strategy {

   @Override
   public void call() {
      log.info("비즈니스 로직2 실행"); 
   }
}
```
```java
@Slf4j
public class ContextV1 {
   
   private Strategy strategy;
   
   public ContextV1(Strategy strategy) { 
      this.strategy = strategy;
   }
   
   public void execute() {
      long startTime = System.currentTimeMillis(); 
      
      //비즈니스 로직 실행
      strategy.call(); //위임
      //비즈니스 로직 종료
      
      long endTime = System.currentTimeMillis(); 
      long resultTime = endTime - startTime; 
      log.info("resultTime={}", resultTime);
   } 
}
```
```java
public class ContextV1Test {

   @Test
   void strategyV1() {
      Strategy strategyLogic1 = new StrategyLogic1(); 
      ContextV1 context1 = new ContextV1(strategyLogic1);
      context1.execute();
      
      Strategy strategyLogic2 = new StrategyLogic2(); 
      ContextV1 context2 = new ContextV1(strategyLogic2); 
      context2.execute();
   }
}
```

**템플릿 콜백 패턴**
* 전략 패턴 중에서 Strategy를 내부 익명 클래스로 정의해서 만든 템플릿 콜백 패턴
* 정식 GOF 패턴은 아니고, 스프링 내부에서 이런 방식을 자주 사용
* 스프링에서 이름에 XxxTemplate 가 있다면 템플릿 콜백 패턴

**템플릿 콜백 패턴 예제 코드**
```java
public interface Callback {
   void call();
}
```
```java
@Slf4j
public class TimeLogTemplate {
   
   public void execute(Callback callback) {
      
      long startTime = System.currentTimeMillis(); 
      
      //비즈니스 로직 실행
      callback.call(); //위임
      //비즈니스 로직 종료
      
      long endTime = System.currentTimeMillis(); 
      long resultTime = endTime - startTime; 
      log.info("resultTime={}", resultTime);
} 
```
```java
@Slf4j
public class TemplateCallbackTest {

   @Test
   void callbackV1() {
      TimeLogTemplate template = new TimeLogTemplate();
      template.execute(new Callback() { 
         @Override
         public void call() {
             log.info("비즈니스 로직1 실행"); 
         }
      });
      
      template.execute(new Callback() { 
         @Override
         public void call() { 
            log.info("비즈니스 로직2 실행");
         } 
      });
   }

   @Test
   void callbackV2() {
      TimeLogTemplate template = new TimeLogTemplate(); 
      template.execute(() -> log.info("비즈니스 로직1 실행")); 
      template.execute(() -> log.info("비즈니스 로직2 실행"));
   } 
}
```
